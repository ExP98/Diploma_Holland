---
title: "Регрессионные модели"
author: "Egor Glushkov"
---

# 1. Библиотеки и функции
```{r include=FALSE}
# set.seed(142)
# source(paste0(here::here(), "/1. R/00. Source_all.R"))
```


# 2. Данные

Разделение данных на трейн и тест:
```{r}
# .[features, targets] <- separate_X_y(wide_data)
# .[X_train, X_test, Y_train, Y_test, split_idx] <- train_test_split(features, targets)
```

valid
```{r}
split_idx <- sample(c(TRUE, FALSE), nrow(features), replace = TRUE, prob = c(0.6, 0.4))

.[X_train_unscaled, X_test_unscaled] <- list(features[split_idx, ], features[!split_idx, ])
.[Y_train, Y_test] <- list(targets[split_idx, ], targets[!split_idx, ])

mean_train <- apply(X_train_unscaled, 2, mean, na.rm = TRUE)
sd_train <- apply(X_train_unscaled, 2, sd, na.rm = TRUE)

X_train <- scale(X_train_unscaled, center = mean_train, scale = sd_train)
X_test  <- scale(X_test_unscaled, center = mean_train, scale = sd_train)

nn <- round(nrow(X_test)/2)
.[X_test, X_valid] <- list(X_test[1:nn, ], X_test[(nn+1):nrow(X_test), ])
.[Y_test, Y_valid] <- list(Y_test[1:nn, ], Y_test[(nn+1):nrow(Y_test), ])
```


# 3. Модель

## 3.1 Выбор предикторов
Stepwise (back, forward), L2-regression

```{r}
### Метод 1: Многомерная пошаговая регрессия (отдельные модели для каждого таргета)
.[lm_ind_pred, lm_chain_pred] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_stepwise_lm_model, X_train, Y_train, X_test, Y_test, T, F
)
```

Признаки после выполнения пошаговой регрессии
```{r}
features_stepw <- sapply(1:6, \(i) stepwise_results[[i]]$model %>% colnames() %>% .[. != "y"])
# reduce(features_stepw, union)
```

```{r}
### Метод 2: Многомерный случайный лес
rf_predictions <- matrix(0, nrow = nrow(X_test), ncol = ncol(Y_test))
colnames(rf_predictions) <- colnames(Y_test)

for(i in 1:ncol(Y_train)) {
  df <- data.frame(X_train, y = Y_train[,i])
  rf_model <- randomForest(y ~ ., data = df)
  rf_predictions[,i] <- predict(rf_model, X_test)
}

show_custom_metrics(rf_predictions, "RF", Y_test_ = Y_test)
```


## 3.2 Важность признаков

```{r}
lapply(xgb_ind_pred, \(x) x$calc_importance())
```
Для XGBoost (и позже для Random Forest) самая важная фича -- CT_1 (открытость-замкнутость)

Порядок предсказания может иметь значение!

```{r}
LightGBM_models <- vector("list", 6)
for (col_i in 1:6) {
  LightGBM_models[[col_i]] <- my_LightGBM_model$new(X_train, Y_train[, col_i], X_test, Y_test[, col_i])
}

res <- lapply(1:6, \(i) lgb.importance(LightGBM_models[[i]]$model, percentage = TRUE)[, .(col = i, Feature, Gain)]) %>% 
  rbindlist() %>% 
  dcast(col ~ Feature, value.var = "Gain", fill = 0) %>% 
  .[, -c("col")]

importance_df <- data.table(
  feature = colnames(res),
  avg_imp = res %>% colMeans()
) %>% 
  .[order(-avg_imp)] %>% 
  .[, cumsum_imp := cumsum(avg_imp)] %>% 
  .[cumsum_imp <= 0.55] %>% 
  .[, names(.SD) := round(.SD, 3), .SDcols = c("avg_imp", "cumsum_imp")]

xlsx::write.xlsx(importance_df, here("0. Data/1. Output/feature_importance.xlsx"))
```


## 3.3 Проверка отдельных параметров моделей

### Константный предсказатель
```{r}
const_pred <- matrix(rep(rep(7, times = 6), each = nrow(Y_test)), nrow = nrow(Y_test))
# const_pred <- matrix(rep(colMeans(Y_train), each = nrow(Y_test)), nrow = nrow(Y_test))

show_custom_metrics(const_pred, "Константное")
```

### LightGBM Cross Validation

```{r}
.[lgbm_cv_ind_pred, lgbm_cv_chain_pred] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_LightGBM_CV_model, X_train, Y_train, X_test, Y_test, T, F
)
```

### Линейная регрессия (lm)

```{r}
lm_ind_pred <- simple_lm(X_train, Y_train, X_test, Y_test)
show_custom_metrics(lm_ind_pred, "lm")
```

```{r}
.[lm_ind_pred, lm_chain_pred] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_lm_model, X_train, Y_train, X_test, Y_test, T, F
)

.[lm_stepw_ind_pred, lm_stepw_chain_pred] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_stepwise_lm_model, X_train, Y_train, X_test, Y_test, T, F
)
```

```{r}
lm_L2_pred <- get_L1_L2_glmnet_preds(alpha = 0) # Ridge
lm_L1_pred <- get_L1_L2_glmnet_preds(alpha = 1) # Lasso
```

При этом по отдельности результат хуже
```{r}
perform_stack_MO_regression(my_L1_L2_glmnet_model, X_train, Y_train, X_test, Y_test, T, alpha = 0)
perform_stack_MO_regression(my_L1_L2_glmnet_model, X_train, Y_train, X_test, Y_test, T, alpha = 1)
```


### kNN

```{r}
for (k in c(3, seq(5, ncol(X_train), 5))) {
  message(paste0("k = ", k))
  perform_stack_MO_regression(my_knn_model, X_train, Y_train, X_test, Y_test, T, F, k = k)
}
```
Лучше k = 5, 20 или 35


## 3.4 Stacking 

Настоящий стэкинг:
```{r}
# library(stacking)
# library(snow)

Method <- list(glmnet = data.frame(alpha = c(0.5, 0.8), lambda = c(0.1, 1)),
               pls = data.frame(ncomp = 5))

stacking_train_result <- NULL

for (i in 1:6) {
  stacking_train_result[[i]] <- stacking_train(
    X = X_train,
    Y = Y_train[, i],
    Method = Method,
    Metamodel = "glmnet",
    core = 2,
    cross_validation = FALSE,
    use_X = TRUE,
    TrainEachFold = TRUE,
    num_sample = 3,
    proportion = 0.8
  ) 
}

st_pred <- lapply(1:6, \(i) stacking_predict(newX = X_test, stacking_train_result[[i]]))
st_pred %>% 
  as.data.table() %>% 
  as.matrix() %>% 
  show_custom_metrics(case_name = "Stacking")
```


```{r}
library(MASS)

final_pred <- NULL

for (hol_i in 1:6) {
  y_train <- Y_train[, hol_i]
  y_test <- Y_test[, hol_i]
  folds <- createFolds(y_train, k = 5, list = TRUE)
  
  base_preds <- matrix(0, nrow = nrow(X_train), ncol = 5)
  colnames(base_preds) <- c("lasso", "ridge", "lightgbm", "catboost", "rf")
  
  # Обучение базовых моделей с out-of-fold предсказаниями
  for (i in 1:length(folds)) {
    fold_idx <- folds[[i]]
    
    # Разделение данных на тренировочную и валидационную части
    X_fold_train <- X_train[-fold_idx, ]
    y_fold_train <- y_train[-fold_idx]
    X_fold_val <- X_train[fold_idx, ]
    
    # L1-регрессия (Lasso)
    lasso <- cv.glmnet(X_fold_train, y_fold_train, alpha = 1)
    base_preds[fold_idx, "lasso"] <- predict(lasso, X_fold_val, s = "lambda.min")
    
    # L2-регрессия (Ridge)
    ridge <- cv.glmnet(X_fold_train, y_fold_train, alpha = 0)
    base_preds[fold_idx, "ridge"] <- predict(ridge, X_fold_val, s = "lambda.min")
    
    # LightGBM
    dtrain <- lgb.Dataset(data = X_fold_train, label = y_fold_train)
    params <- list(objective = "regression", metric = "rmse", num_iterations = 250)
    lgb_model <- lgb.train(params, dtrain, 100, verbose = -1)
    base_preds[fold_idx, "lightgbm"] <- predict(lgb_model, X_fold_val)
    
    # CatBoost
    pool_train <- catboost.load_pool(data = X_fold_train, label = y_fold_train)
    pool_val <- catboost.load_pool(data = X_fold_val)
    cat_model <- catboost.train(pool_train, NULL, params = list(loss_function = 'RMSE', logging_level = "Silent", allow_writing_files = FALSE))
    base_preds[fold_idx, "catboost"] <- catboost.predict(cat_model, pool_val)
    
    # Random Forest
    rf_model <- randomForest(X_fold_train, y_fold_train, ntree = 1000)
    base_preds[fold_idx, "rf"] <- predict(rf_model, X_fold_val)
  }
  
  # Обучение мета-модели на предсказаниях базовых моделей
  meta_train <- data.frame(base_preds, target = y_train)
  meta_model <- lm(target ~  ., data = meta_train)
  
  # Переобучение базовых моделей на полных данных
  final_lasso <- cv.glmnet(X_train, y_train, alpha = 1)
  final_ridge <- cv.glmnet(X_train, y_train, alpha = 0)
  final_rf <- randomForest(X_train, y_train, ntree = 1000)
  
  # LightGBM final
  dtrain_full <- lgb.Dataset(data = X_train, label = y_train)
  lgb_final <- lgb.train(params, dtrain_full, 100, verbose = -1)
  
  # CatBoost final
  pool_full <- catboost.load_pool(X_train, label = y_train)
  cat_final <- catboost.train(pool_full, NULL, 
                              params = list(loss_function = 'RMSE', logging_level = "Silent",
                                            allow_writing_files = FALSE))
  
  # Предсказания на тестовых данных
  test_preds <- data.table(
    lasso = predict(final_lasso, X_test, s = "lambda.min"),
    ridge = predict(final_ridge, X_test, s = "lambda.min"),
    lightgbm = predict(lgb_final, X_test),
    catboost = catboost.predict(cat_final, catboost.load_pool(X_test)),
    rf = predict(final_rf, X_test)
  ) %>% 
    setnames(c("lasso", "ridge", "lightgbm", "catboost", "rf"))
  
  # Финальное предсказание мета-модели
  final_pred[[hol_i]] <- predict(meta_model, newdata = test_preds)
}
```

```{r}
final_pred %>% 
  as.data.table() %>% 
  as.matrix() %>% 
  show_custom_metrics(case_name = "Stacking", need_to_correct = TRUE)
```

Стэкинг из lm, rpart, randomForest: Stacking. aRMSE: 1.98; aCindex: 9.926


## 3.5 PCA

```{r}
pca_model <- prcomp(X_train, center = TRUE, scale. = TRUE)

# cumsum(pca_model$sdev^2 / sum(pca_model$sdev^2))
data.table(
  k = 1:length(pca_model$sdev),
  ssq = pca_model$sdev^2
) %>% 
  .[, cumsum := cumsum(ssq / sum(ssq))] %>% 
  .[]

plot(pca_model$sdev^2 / sum(pca_model$sdev^2), 
     type = "b", 
     xlab = "Главные компоненты", 
     ylab = "Доля объясненной дисперсии")
```

На примере lm

Зависимость k (~PCA) и результатов lm:
```{r}
res_k_lm1 <- get_k_PCA_model_table(my_lm_model, by = 1, metric_f = c_index_dist)
res_k_lm2 <- get_k_PCA_model_table(my_lm_model, by = 1, metric_f = my_rmse)
```

k = 29
```{r}
best_k <- res_k_lm1[avg_metric == min(avg_metric), k]
print(str_glue("Best k: {best_k}"))
X_train_pca <- pca_scaler(X_train, pca_model, k = best_k)
X_test_pca  <- pca_scaler(X_test,  pca_model, k = best_k)

.[lm_pca_ind_pred, lm_pca_chain_pred] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_lm_model, X_train_pca, Y_train, X_test_pca, Y_test, T, F
)
```


# 4. Ансамбли

## 4.1 Взвешенное ансамблирование (блендинг) на данных без пропусков

Какие модели используем (функция/класс, имя, доп. параметры):
```{r}
regr_experiments <- tribble(
  ~model,                   ~name,                  ~need_MO, ~params,
  const_model,              "const",                FALSE,    list(),
  regularized_lm,           "Lasso L1",             FALSE,    list(alpha = 1),
  regularized_lm,           "Ridge L2",             FALSE,    list(alpha = 0),
  simple_lm,                "lm",                   FALSE,    list(),
  my_stepwise_lm_model,     "stepwise lm",          TRUE,     list(),
  my_XGBoost_model,         "XGBoost",              TRUE,     list(),
  my_LightGBM_model,        "LightGBM",             TRUE,     list(),
  my_Catboost_model,        "CatBoost",             TRUE,     list(),
  my_RandomForest_model,    "Random Forest (500)",  TRUE,     list(ntree = 500),
  my_RandomForest_model,    "Random Forest (1000)", TRUE,     list(ntree = 1000),
  my_knn_model,             "kNN (k = 5)",          TRUE,     list(k = 5),
  my_knn_model,             "kNN (k = 25)",         TRUE,     list(k = 25),
  my_knn_model,             "kNN (k = 50)",         TRUE,     list(k = 50),
  my_SVR_model,             "SVR",                  TRUE,     list(kernel = "sigmoid"),
  my_ET_model,              "ExtraTree (500)",      TRUE,     list(ntree = 500),
  my_ET_model,              "ExtraTree (2000)",     TRUE,     list(ntree = 2000)
) %>%
  as.data.table()

model_to_exclude <- c("Random Forest (500)", "ExtraTree (500)", "kNN (k = 5)", "const", "lm")
```

### Без уменьшения размерности (PCA)

Результаты по моделям:
```{r}
regr_stack_res <- calc_regression_models(regr_experiments, MO_strategy = "stack",
                                         X_train, Y_train, X_test, Y_test)

regr_chain_res <- calc_regression_models(regr_experiments, MO_strategy = "chain",
                                         X_train, Y_train, X_test, Y_test)

regr_res_file <- here("0. Data/1. Output/regression_results.xlsx")
xlsx::write.xlsx(regr_stack_res[order(-C_index), -"pred"],
                 regr_res_file, "stack", row.names = F, append = T)
xlsx::write.xlsx(regr_chain_res[order(-C_index), -"pred"], 
                 regr_res_file, "chain", row.names = F, append = T)
```

Нахождение весов по различным наборам моделей (независимым / по цепочке / только лучшие):
```{r}
stack_mtr <- regr_stack_res[!name %in% model_to_exclude] %>% extract_matrices()
chain_mtr <- regr_chain_res[!name %in% model_to_exclude] %>% extract_matrices()

stack_mtr_f <- cut_matr(stack_mtr, qnt_prob = 0.6, Y_true = Y_test)
chain_mtr_f <- cut_matr(chain_mtr, qnt_prob = 0.6, Y_true = Y_test)

regr_stack_w   <- get_regr_w(w_config, stack_mtr, Y_test)
regr_chain_w   <- get_regr_w(w_config, chain_mtr, Y_test)
regr_stack_w_f <- get_regr_w(w_config, stack_mtr_f, Y_test)
regr_chain_w_f <- get_regr_w(w_config, chain_mtr_f, Y_test)

# beepr::beep()
```
Код run_weights_search_experiments выполняется минуты 4 на полном наборе моделей и 2 на усеченном

```{r}
reg_ens_fname <- here("0. Data/1. Output/regression_ensemble_results.xlsx")

write_w_search_to_xlsx(regr_stack_w  , stack_mtr  , "stack", reg_ens_fname)
write_w_search_to_xlsx(regr_stack_w_f, stack_mtr_f, "filtered stack", reg_ens_fname)
write_w_search_to_xlsx(regr_chain_w  , stack_mtr  , "chain", reg_ens_fname)
write_w_search_to_xlsx(regr_chain_w_f, chain_mtr_f, "filtered chain", reg_ens_fname)
```
Один такой блок кода от и до выполняется 10 минут. 


### С использованием PCA

```{r}
.[X_train_pca, X_test_pca] <- pca_data_preparation(X_train, X_test, limit_ssq = 0.9)
```

Результаты по моделям:
```{r}
regr_stack_res_pca <- calc_regression_models(regr_experiments, MO_strategy = "stack",
                                             X_train_pca, Y_train, X_test_pca, Y_test)

regr_chain_res_pca <- calc_regression_models(regr_experiments, MO_strategy = "chain",
                                             X_train_pca, Y_train, X_test_pca, Y_test)

regr_stack_res_pca[order(-C_index), -"pred"] %>% 
  xlsx::write.xlsx(regr_res_file, "stack PCA", row.names = F, append = T)

regr_chain_res_pca[order(-C_index), -"pred"] %>% 
  xlsx::write.xlsx(regr_res_file, "chain PCA", row.names = F, append = T)
```

Нахождение весов по различным наборам моделей (независимым / по цепочке / только лучшие):
```{r}
stack_mtr_pca <- regr_stack_res_pca[!name %in% model_to_exclude] %>% extract_matrices()
chain_mtr_pca <- regr_chain_res_pca[!name %in% model_to_exclude] %>% extract_matrices()

stack_mtr_f_pca <- cut_matr(stack_mtr_pca, qnt_prob = 0.6, Y_true = Y_test)
chain_mtr_f_pca <- cut_matr(chain_mtr_pca, qnt_prob = 0.6, Y_true = Y_test)

regr_stack_w_pca   <- get_regr_w(w_config, stack_mtr_pca, Y_test)
regr_chain_w_pca   <- get_regr_w(w_config, chain_mtr_pca, Y_test)
regr_stack_w_f_pca <- get_regr_w(w_config, stack_mtr_f_pca, Y_test)
regr_chain_w_f_pca <- get_regr_w(w_config, chain_mtr_f_pca, Y_test)

# beepr::beep()
```

```{r}
write_w_search_to_xlsx(regr_stack_w_pca  , stack_mtr_pca  , "stack PCA", reg_ens_fname)
write_w_search_to_xlsx(regr_stack_w_f_pca, stack_mtr_f_pca, "filtered stack PCA", reg_ens_fname)
write_w_search_to_xlsx(regr_chain_w_pca  , stack_mtr_pca  , "chain PCA", reg_ens_fname)
write_w_search_to_xlsx(regr_chain_w_f_pca, chain_mtr_f_pca, "filtered chain PCA", reg_ens_fname)
```



## 4.2 Взвешенное ансамблирование (блендинг) отдельно на психологических тестах

Найти наилучшую модель для каждого из тестов. Мб миксовать с PCA.

```{r}
prepare_psytest_dataset_by_split <- function(input_dt, psytest_label = c("BF", "EY", "CT", "LN", "SC")) {
  psytest_label <- match.arg(psytest_label)
  
  input_dt <- input_dt %>% 
    copy() %>% 
    .[, .SD, .SDcols = names(input_dt) %like% paste0(psytest_label, "|HL")] %>% 
    drop_na()
  
  split_idx <- sample(c(TRUE, FALSE), nrow(input_dt), replace = TRUE, prob = c(0.8, 0.2))
  
  .[X_train_unscaled, X_test_unscaled] <- list(
    input_dt[split_idx, .SD, .SDcols = names(input_dt) %like% psytest_label], 
    input_dt[!split_idx, .SD, .SDcols = names(input_dt) %like% psytest_label])
  
  .[Y_train, Y_test] <- list(input_dt[split_idx, .SD, .SDcols = names(input_dt) %like% "HL_"], 
                             input_dt[!split_idx, .SD, .SDcols = names(input_dt) %like% "HL_"]) %>% 
    lapply(as.matrix)
  
  mean_train <- apply(X_train_unscaled, 2, mean, na.rm = TRUE)
  sd_train <- apply(X_train_unscaled, 2, sd, na.rm = TRUE)
  
  X_train <- scale(X_train_unscaled, center = mean_train, scale = sd_train)
  X_test  <- scale(X_test_unscaled, center = mean_train, scale = sd_train)
  
  if (nrow(X_train) == 0 | nrow(X_test) == 0) error("X_train or X_test are empty!")
  
  return(list(X_train = X_train, Y_train = Y_train, X_test = X_test, Y_test = Y_test))
}
```

Важно: обучаем на новых потестовых данных (wide_data2), оцениваем на wide_data (старые данные, которые есть по всем тестам, потому в конце можно оценивать ансамбль на них же).


### Catboost
Для примера берем Catboost и обучаем его на данных каждого и тестов по отдельности.

1. BF
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "BF")

.[BF_catb_ind, BF_catb_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_Catboost_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```

2. EY
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "EY")

.[EY_catb_ind, EY_catb_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_Catboost_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```


3. CT
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "CT")

.[CT_catb_ind, CT_catb_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_Catboost_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```

4. LN
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "LN")

.[LN_catb_ind, LN_catb_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_Catboost_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```

5. SC
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "SC")

.[SC_catb_ind, SC_catb_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_Catboost_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```

Ансамбль
```{r}
models_pred <- list(BF_catb_chain, EY_catb_ind, CT_catb_ind, LN_catb_ind, SC_catb_ind)

w1 <- rep(1/length(models_pred), length(models_pred))
w2 <- c(1, 1, 10, 5, 2) # BF 2.203 (1), EY 2.203 (1), CT 2.089 (10), LN 2.149 (5), SC 2.192 (2)

scalar_matrix_production(w_vec = w1, models_pred) %>% 
  show_custom_metrics("All equal", Y_test_ = df[["Y_test"]])

scalar_matrix_production(w_vec = w2, models_pred) %>% 
  show_custom_metrics("All preferences", Y_test_ = df[["Y_test"]])
```
Catboost:
All equal. aRMSE: 2.117; aCosDist: 0.288
All preferences. aRMSE: 2.083; aCosDist: 0.284


### Random Forest

1. BF
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "BF")

.[BF_rf_ind, BF_rf_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_RandomForest_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```

2. EY
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "EY")

.[EY_rf_ind, EY_rf_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_RandomForest_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```


3. CT
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "CT")

.[CT_rf_ind, CT_rf_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_RandomForest_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```

4. LN
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "LN")

.[LN_rf_ind, LN_rf_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_RandomForest_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```

5. SC
```{r}
df <- prepare_psytest_dataset(wide_data, wide_data2, "SC")

.[SC_rf_ind, SC_rf_chain] <- map(
  list(perform_stack_MO_regression, perform_chain_MO_regression), exec,
  my_RandomForest_model, df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], T, F
)

rep(colMeans(df[["Y_train"]]), each = nrow(df[["Y_test"]])) %>% 
  matrix(nrow = nrow(df[["Y_test"]])) %>% 
  show_custom_metrics("Константное", Y_test_ = df[["Y_test"]])
```

Ансамбль
```{r}
# list(BF_rf_chain 2.243, EY_rf_ind 2.241, CT_rf_ind 2.089, LN_rf_ind 2.193, SC_rf_ind 2.205)
models_pred <- list(BF_rf_chain, EY_rf_ind, CT_rf_ind, LN_rf_ind, SC_rf_ind)

w1 <- rep(1/length(models_pred), length(models_pred))
w2 <- c(1, 1, 6, 2, 2)
w3 <- c(1, 1, 10, 2, 2)

scalar_matrix_production(w_vec = w1, models_pred) %>% 
  show_custom_metrics("All equal", Y_test_ = df[["Y_test"]])

scalar_matrix_production(w_vec = w2, models_pred) %>% 
  show_custom_metrics("All preferences", Y_test_ = df[["Y_test"]])

scalar_matrix_production(w_vec = w3, models_pred) %>% 
  show_custom_metrics("All preferences 2", Y_test_ = df[["Y_test"]])
```

### Пример поиска лучшей модели для одного теста

Перечислим все модели:
```{r}
one_test_model_map <- function(model, df_ = df) {
  x <- map(
    list(perform_stack_MO_regression), exec, # perform_chain_MO_regression
    model, df_[["X_train"]], df_[["Y_train"]], df_[["X_test"]], df_[["Y_test"]], T, F
  )
}


show_constant_pred_metric <- function(df_) {
  res <- rep(colMeans(df_[["Y_train"]]), each = nrow(df_[["Y_test"]])) %>% 
    matrix(nrow = nrow(df_[["Y_test"]])) %>% 
    show_custom_metrics("Константное", Y_test_ = df_[["Y_test"]])
  return(res)
}


class_models <- data.table(
  models = list(my_lm_model, my_XGBoost_model, my_LightGBM_model, my_Catboost_model, my_RandomForest_model, my_knn_model, my_SVR_model),
  labels = list("lm", "XGBoost", "LightGBM", "CatBoost", "Random Forest", "kNN", "SVR")
)


# class_models2 <- data.table(
#   models = list(my_lm_model),
#   labels = list("lm")
# )
```

c("BF", "EY", "CT", "LN", "SC")
```{r}
sink("model_log_noPCA.txt", append = TRUE, split = TRUE)

models_by_tests <- NULL

for (test_lbl in c("BF", "EY", "CT", "LN", "SC")) {
  cat(test_lbl, "\n")
  # for (pca_b in c(TRUE, FALSE)) {
    # pca_lbl <- if (pca_b) "PCA" else "no PCA"
    
    # cat(pca_lbl, "\n")
    df <- prepare_psytest_dataset(wide_data, wide_data2, test_lbl, use_PCA_b = FALSE)
    # models_by_tests[[test_lbl]][[pca_lbl]] <- map(class_models$models, one_test_model_map, df_ = df)
    
    for (i in 1:nrow(class_models)) {
      models_by_tests[[test_lbl]][[class_models[i, labels][[1]]]] <- one_test_model_map(class_models[i, models][[1]], df)
    }
    
    # models_by_tests[[test_lbl]] <- map(class_models$models, one_test_model_map, df_ = df)
    models_by_tests[[test_lbl]][["Lasso"]] <- get_L1_L2_glmnet_preds(df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], alpha = 1)
    models_by_tests[[test_lbl]][["Ridge"]] <- get_L1_L2_glmnet_preds(df[["X_train"]], df[["Y_train"]], df[["X_test"]], df[["Y_test"]], alpha = 0)
    show_constant_pred_metric(df) %>% cat()
    cat("\n")
  # }
  # cat("\n\n")
}

sink()
```

```{r}
for (test_lbl in c("BF", "EY", "CT", "LN", "SC")) {
  cat(test_lbl, "\n")
  df <- prepare_psytest_dataset(wide_data, wide_data2, test_lbl, use_PCA_b = FALSE)
  show_constant_pred_metric(df) %>% cat()
  cat("\n")
}
```

```{r}
for (cur_label in c("BF", "EY", "CT", "LN", "SC")) {
  df <- prepare_psytest_dataset(wide_data, wide_data2, cur_label, use_PCA_b = FALSE)
  mbt <- models_by_tests[[cur_label]]
  
  scalar_matrix_production(w_vec = rep(1/length(mbt), length(mbt)), lapply(names(mbt), \(ii) pluck(x, ii, 1))) %>% 
    show_custom_metrics("All equal", Y_test_ = df[["Y_test"]]) %>% 
    print()
}
```

```{r}
# models_pred <- list(x[[1]][[1]], x[[2]][[2]], x[[3]][[1]], x[[4]][[2]], x[[5]][[1]], x[[6]][[1]])
models_pred <- list(x[[1]][[1]], x[[2]][[2]], x[[3]][[1]], x[[4]][[1]], x[[5]][[1]], x[[6]][[1]])

w1 <- rep(1/length(models_pred), length(models_pred))
w2 <- c(1, 2, 2, 2, 9, 2)

scalar_matrix_production(w_vec = w1, models_pred) %>% 
  show_custom_metrics("All equal", Y_test_ = df[["Y_test"]])

scalar_matrix_production(w_vec = w2, models_pred) %>% 
  show_custom_metrics("All preferences", Y_test_ = df[["Y_test"]])
```

LN (no PCA):
```{r}
models_pred2 <- list(x[[1]][[1]], x[[2]][[1]], x[[3]][[2]], x[[4]][[1]], x[[5]][[1]], x[[6]][[1]])
w3 <- c(1, 3, 3, 3, 3, 13)

scalar_matrix_production(w_vec = w3, models_pred2) %>% 
  show_custom_metrics("All preferences", Y_test_ = df[["Y_test"]])
```


# 5. Распределение и сбалансированность предсказаний кодов Голланда

Распределение значений кодов HL_1:HL_6 предсказаний:
```{r}
df_long_preds <- as.data.table(rf_ind_pred) %>%  # lm_L1_pred
  setnames(paste0("HL_", 1:6)) %>% 
  .[, id := .I] %>% 
  pivot_longer(cols = HL_1:HL_6, names_to = "Group", values_to = "Value")


ggplot(df_long_preds, aes(x = Value, color = Group, fill = Group)) +
  geom_density(alpha = 0.2) +
  labs(title = "Накладывающиеся графики плотности предсказаний", x = "Значение", y = "Плотность") +
  theme_minimal()

ggplot(df_long_preds, aes(x = Value, color = Group, fill = Group)) +
  geom_density(alpha = 0.2) +
  labs(title = "Накладывающиеся графики плотности предсказаний", x = "Значение", y = "Плотность") +
  facet_wrap(~ Group) +
  theme_minimal()

ggplot(df_long_preds, aes(x = Value, y = Group, fill = stat(x))) +
  geom_density_ridges_gradient() +
  scale_fill_viridis_c(name = "Temp.", option = "C") +
  labs(title = "Накладывающиеся графики плотности предсказаний", x = "Значение", y = "Плотность") +
  theme_minimal()
```

Распределение значений топ1:топ6 предсказаний:
```{r}
value_rank_df <- df_long_preds %>% 
  as.data.table() %>% 
  .[order(id, -Value)] %>% 
  .[, rank := paste0("rank_", 1:.N), by = .(id)] %>% 
  .[, .(Value, rank)]

ggplot(value_rank_df, aes(x = Value, color = rank, fill = rank)) +
  geom_density(alpha = 0.2) +
  labs(title = "Накладывающиеся графики плотности", x = "Значение", y = "Плотность") +
  facet_wrap(~ rank) +
  theme_minimal()

ggplot(value_rank_df, aes(x = Value, y = rank, fill = stat(x))) +
  geom_density_ridges_gradient() +
  scale_fill_viridis_c(name = "Temp.", option = "C") +
  labs(title = "Частоты значений кодов предсказаний по убыванию") +
  theme_minimal()
```


# 6. Сохранение модели

```{r}
cv_glm <- cv.glmnet(X_train, Y_train, family = "mgaussian", alpha = 1)
# saveRDS(cv_glm, here("3. Shiny_app/model/MODEL_cv_glm.rds"))

glm_pred <- predict(cv_glm, newx = X_test[1, , drop = F], s = "lambda.min")[,,1] %>% 
  smart_integer_round()
```
